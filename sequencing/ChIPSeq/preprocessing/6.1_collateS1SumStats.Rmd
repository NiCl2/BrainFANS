---
title: "Collate Stage 1 Summary Statistics"
date: "`r Sys.Date()`"
output: html_document
params:
  project: !r commandArgs(trailingOnly=T)[3]
  configFile: !r paste0(commandArgs(trailingOnly=T)[2], "/ATACSeq/config/config.r")
---

```{r setup, include=FALSE}
project='adChip'
source("/gpfs/mrc0/projects/Research_Project-MRC190311/scripts/sequencing/ChIPSeq/config/config.r")


library(ChIPQC)
library(knitr)
library(dplyr)
library(reshape)
library('TxDb.Hsapiens.UCSC.hg38.knownGene')
library("BiocParallel")
library(org.Hs.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)
library(GenomicRanges)

load(paste0(peakDir, "/QCOutput/ChIPQCObject.rdata"))

## create colourblind friendly palette
colorBlindGrey8   <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                       "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

```

This report provides a summary of a ChIP-seq experiment from the resulting sequencing data. It looks at metrics from the raw sequencing data, alignment and filtering (and peak calling steps). The bioinformatic pipeline parallels that of the [ENCODE ChIP-seq guidelines] (https://www.encodeproject.org/atac-seq/). Raw fastq files have been have been aligned with Bowtie2 to the human genome (hg38) and peaks called with MACS2 for each individual sample. The pipeline is still under development.

``` {r load, echo =FALSE}
pheno<-read.table(sampleSheet, header = TRUE, sep = ',', stringsAsFactors = FALSE)
## PROGRESS SUMMARY
processSum <- read.csv(paste0(metaDir, "/summariseSampleProcessingProgress.csv"), stringsAsFactors = FALSE, strip.white = TRUE)
## MULTIQC
fastqc<-read.table(paste0(fastQCDir, "/multiqc/multiqc_data/multiqc_fastqc.txt"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
## MITOCHONDRIAL READS
#readCounts<-read.table(paste0(alignedDir, "/countMTReads.txt"), fill = TRUE, skip = 1)
## ALIGNMENT STATISTICS
alignQC<-read.table(paste0(alignedDir, "/multiqc/multiqc_data/multiqc_bowtie2.txt"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
## ENCODE METRICS
#flagstat<-read.csv(paste0(alignedDir, "/ENCODEMetrics/collateFlagStatMetrics.txt"), header = FALSE)
## FRIP
fripFiles <- list.files(paste0(peakDir, "/QCOutput"), pattern = "FRIP")
#----------------------------------------------------------------------#
# WRANGLE DATA
#----------------------------------------------------------------------#
## a. METADATA
## check metadata is in the correct format
# METADATA REQUIREMENTS:
# essential columns: "sampleID",  "cohort", "fraction", "experiment", "individualID"
# samples can be identified as unique from sampleID, cohort, fraction and individualID
missingCol<-setdiff(c("sequencingBatch", "sampleID",  "cohort", "fraction", "experiment", "individualID"), colnames(pheno))
if (length(missingCol) != 0 ) {
  if ("sequencingBatch" %in% missingCol){
    pheno$sequencingBatch<-pheno$cohort
    if (length(missingCol) > 1) {
      warning('Incorrect column names. Missing column(s): ', list(missingCol))
      stop()
    }
  }
}

table(pheno$fraction)

## c. MULTIQC
## wrangle multiqc stats to retain important columns
colsKeep<-c("Total.Sequences","total_deduplicated_percentage", "Sequences.flagged.as.poor.quality")
mergeStats<-cbind(fastqc[match(processSum$R1Filename, fastqc$Filename),colsKeep], fastqc[match(processSum$R2Filename, fastqc$Filename),colsKeep])

## e. ALIGNMENT QC

mergeStats<-cbind(mergeStats,alignQC[,c("overall_alignment_rate", "paired_total")])

## f. ENCODE METRICS
files<-list.files(paste0(alignedDir, "/ENCODEMetrics"), pattern = ".pbc.qc")
eMetrics<-NULL
for(each in files){
  tmp<-read.table(paste0(alignedDir, "/ENCODEMetrics/", each))
  eMetrics<-rbind(eMetrics, tmp)
}
eMetrics
colnames(eMetrics)<-c("TotalReadPairs","DistinctReadPairs","OneReadPair","TwoReadPairs","NRF","PBC1","PBC2")
eIndex<-match(processSum$sampleID, gsub(".filt.srt.nodup.pbc.qc", "", files))
eMetrics<-eMetrics[eIndex,]
mergeStats<-cbind(mergeStats,eMetrics)


#----------------------------------------------------------------------#
# COUNT SAMPLES
#----------------------------------------------------------------------#
## count number of samples with X million reads
readThres<-seq(0,max(mergeStats[,1], na.rm = TRUE)+10^6, 10^6)
nSamples<-matrix(data = NA, nrow = length(readThres), ncol = length(unique(pheno$sequencingBatch))+1)
for(i in readThres){
  nSamples[1+(i/10^6),1] <- sum(mergeStats[,1] > i, na.rm = TRUE)
  colNum<-2
  for(each in unique(pheno$sequencingBatch)){
    nSamples[1+(i/10^6),colNum] <- sum(mergeStats[which(pheno$sequencingBatch == each),1] > i, na.rm = TRUE)
    colNum<-colNum+1
  }
}
```

## Sequencing

```{r pressure, fig.align = 'center', dpi = 500, echo=FALSE}
par(mfrow = c(2,2))
hist(mergeStats[,1], main = "R1", xlab = "Number of Reads", ylab = "Number of Samples", breaks = 100)
hist(mergeStats[,4], main = "R2", xlab = "Number of Reads", ylab = "Number of Samples", breaks = 100)
hist(mergeStats[,2], main = "R1", xlab = "% unique reads", ylab = "Number of Samples", breaks = 100)
hist(mergeStats[,5], main = "R2", xlab = "% unique reads", ylab = "Number of Samples", breaks = 100)
```

```{r alignment rate, fig.align = 'center', dpi = 500, echo = FALSE}
## a. Plot alignment rate against number of reads
plot(mergeStats[,"paired_total"], mergeStats[,"overall_alignment_rate"], xlab = "Number of Reads", ylab = "Alignment rate", pch = 16, col = colorBlindGrey8[as.factor(pheno$fraction)])
abline(h = 95, lty = 2)
abline(h = 80, lty = 2, col = "#66C2A5")
```

## ChIP Signal Distribution and Structure

These metrics inspect distribution of global pile-up across the genome. 

### Coverage histogram

In the histogram of coverage depths, the X-axis represents the read pileup height at a basepair position, and the Y-axis represents how many positions have this pileup height on a log scale. A ChIP sample with good enrichment should have a reasonable "tail".


```{r covhist, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotCoverageHist(dat,colourBy=('Factor'), facetBy=("Tissue")) +
  theme_minimal() +
  scale_colour_brewer(palette = "Set2")
```

### Standard deviation of coverage

SSD is the standard deviation of coverage normalised to the total number of reads. Samples with low enrichment, consisting of mostly background reads and genome-wide low pile-up (such as in controls), should have lower SSD values than good ChIP samples. Equivalence of sample and input SSD scores highlights either an unsuccessful ChIP or high levels of anomalous input signal, and hence a flag for further blacklisting of genomic regions.

To assess the contribution of artefact signal to global distrubtion of signal pileup, SSD is measured before and after exclusion of signal from known blacklisted regions.


```{r ssd, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotSSD(dat, facetBy=c("Tissue", "Factor"))+
  theme_minimal()+
  scale_colour_brewer(palette = "Set2")
```

## Cross-correlation

A high quality ChIP-seq experiment produces significant clustering around protein binding sites, with this density accumulating on the forward and reverse strands centred around the binding site. These ‘‘true signal’’ sequence tags are positioned at a distance from the binding site centre that depends on the fragment size distribution. The degree to which your ChIP-seq signal is clustered around such sites can be exploited as a metric of ChIP efficiency.

In ChIPQC the reduction in total genome covered which occurs from shifting the Watson reads along the genome (from 5’ to 3’ of chromsome) is assessed. This is performed by measuring total coverage after each every successive shift of 1bp. As the Watson reads overlap the Crick reads around peaks, the total genome covered will be reduced. The total coverage after each successive shift is then converted to cross-coverage scores after each shift.

The cross-coverage scores after successive shifts can then be visualised and reviewed. There should be a distinctive peak around the read length and a second peak at the expected fragment length. 

```{r cc, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotCC(dat, colourBy=('Factor'), facetBy=("Tissue"))+
  theme_minimal()+
  scale_colour_brewer(palette = "Set2")
```

## Peak Profile and ChIP Enrichment

## Peak profiles

Each peak is centered on its summit (point of highest pileup after
extending the reads to the calculated fragment length), and the pileup values at bases in a window upstream and downstream of the summits is computed and averaged for all peaks in the sample. Good ChIPs will show distinctive patterns of enrichment in these peaks, while associated controls will be relatively flat.

```{r peakProf, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotPeakProfile(dat, colourBy=('Factor'), facetBy=("Tissue"))+
  scale_colour_brewer(palette = "Set2")
```

### Plotting Relative Enrichment of reads in Genomic Intervals

A heatmap plot showing relative enrichment of reads around annotated genomic features.

```{r relativeEnrich, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotRegi(dat, facetBy=c("Tissue", "Factor")) + 
  theme_minimal()+
  theme(text = element_text(size=10),
        axis.text.x = element_text(angle=90))+
  scale_fill_viridis_c()

nPeaks<-unlist(lapply(peaks(dat), length))
peakAnnoList <- lapply(peaks(dat)[which(nPeaks > 0)], annotatePeak,tssRegion=c(-500, 500), 
                       TxDb=TxDb.Hsapiens.UCSC.hg38.knownGene, 
                       annoDb="org.Hs.eg.db")
plotAnnoBar(peakAnnoList) +
  theme_minimal()+
  scale_colour_brewer(palette = "Set2") +
  theme(text = element_text(size=10))
  
```

### Specificity of reads in peaks

The first plot shows the percentage of reads that overlap called peaks (also known as FRIP). This is a good indication of how "enriched" the sample is, and can be considered a "signal-to-noise" measure of what proportion of the library consists of fragments from binding sites vs. background reads.

The second plot shows the percentage of reads that overlapped blacklisted regions (RiBL). The signal from blacklisted has been shown to contribute to confound peak callers and fragment length estimation as well as to contribute to the read length peak in cross coverage. The RiBL score then may act as a guide for the level of background signal in a ChIP or input.

```{r fripfribl, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotRap(dat, facet = FALSE) + 
  theme_minimal()+
  theme(text = element_text(size=10), 
        axis.title.y = element_text(size = 10),
        axis.text.x = element_text(angle=90)) +
  scale_fill_brewer(palette = "Set2")

par(mfrow = c(1,2))
plotFrip(dat, facet = FALSE) + 
  theme_minimal()+
  theme(text = element_text(size=10), 
        axis.title = element_text(size = 10),
        axis.text.x = element_text(angle=90))

plotFribl(dat, facet = FALSE) + 
  theme_minimal()+
  theme(text = element_text(size=10), 
        axis.title = element_text(size = 10),
        axis.text.x = element_text(angle=90))
```

### Sample clustering

The correlation heatmap is based on correlation values for all the peak scores for each sample. The other plot shows the first two principal component values for each sample.

``` {r cluster, fig.align = 'center', dpi = 500, echo=FALSE, warning=FALSE, results=FALSE}
plotCorHeatmap(dat,attributes=c("Tissue","Factor"))
plotPrincomp(dat,attributes=c("Tissue","Factor"))
```