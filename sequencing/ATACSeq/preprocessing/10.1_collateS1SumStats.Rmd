---
title: "Stage 1 Summary Statistics"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
params:
  project: !r commandArgs(trailingOnly=T)[3]
  configFile: !r file.path(commandArgs(trailingOnly=T)[2], "/ATACSeq/config/config.r")
---

```{r setup, include=FALSE}
# load packages
library(dplyr)
library(plyr)
library(knitr)
library(vioplot)
library(corrplot)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(cowplot)

## load config variables
if (is.na(params$project)){
  project<-"rizzardi"
  source("/lustre/projects/Research_Project-MRC190311/scripts/sequencing/ATACSeq/config/config.r")

} else {
    project<-params$project
  source(params$configFile)
}


## create colourblind friendly palette
colorBlindGrey8   <- c("#009E73", "#CC79A7", "#D55E00", "#999999", 
                       "#F0E442", "#0072B2",  "#E69F00", "#56B4E9")
```

This report provides a summary of an ATAC-seq experiment from the resulting sequencing data. It looks at metrics from the raw sequencing data, alignment and filtering (and peak calling steps). The bioinformatic pipeline parallels that of the [ENCODE ATAC-seq guidelines] (https://www.encodeproject.org/atac-seq/). Raw fastq files have been have been aligned with Bowtie2 to the human genome (hg38) and peaks called with MACS2 for each individual sample. The pipeline is still under development.

```{r loadDat, message = FALSE, results='hide'}
# import data
pheno<-read.table(sampleSheet, header = TRUE, sep = ',', stringsAsFactors = FALSE)
processSum <- read.csv(file.path(metaDir, "/summariseSampleProcessingProgress.csv"), stringsAsFactors = FALSE, strip.white = TRUE)
fastqc<-read.table(file.path(fastQCDir, "/multiqc/multiqc_data/multiqc_fastqc.txt"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
readCounts<-read.table(file.path(alignedDir, "/countMTReads.txt"), fill = TRUE, skip = 1)
alignQC<-read.table(file.path(alignedDir, "/multiqc/multiqc_data/multiqc_bowtie2.txt"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
flagstat<-read.csv(file.path(alignedDir, "/ENCODEMetrics/collateFlagStatMetrics.txt"), header = FALSE)
fripFiles <- list.files(file.path(peakDir, "/QCOutput"), pattern = "FRIP")

# wrangle data
missingCol<-setdiff(c("sequencingBatch", "sampleID",  "cohort", "fraction", "experiment", "individualID"), colnames(pheno))
if (length(missingCol) != 0 ) {
  if ("sequencingBatch" %in% missingCol){
    pheno$sequencingBatch<-pheno$cohort
      if (length(missingCol) > 1) {
      warning('Incorrect column names. Missing column(s): ', list(missingCol))
      stop()
    }
  }
}
## exclude duplicates from metadata
dups<-names(which(table(paste(pheno$individualID, pheno$fraction, pheno$tissue, sep = "_")) > 1))
pheno<-unique(pheno[,intersect(c("sequencingBatch", "sampleID","cohort","fraction","individualID", "tissue"), colnames(pheno))])

processSum <- processSum[match(pheno$sampleID, processSum$sampleID),]

## c. MULTIQC
## wrangle multiqc stats to retain important columns
colsKeep<-c("Total.Sequences","total_deduplicated_percentage", "Sequences.flagged.as.poor.quality")
mergeStats<-cbind(fastqc[match(processSum$R1Filename, fastqc$Filename),colsKeep], fastqc[match(processSum$R2Filename, fastqc$Filename),colsKeep])

## d. MITOCHONDRIAL READS
readCounts<-readCounts[match(pheno$sampleID, readCounts$V1),]
mergeStats<-cbind(mergeStats, readCounts$V2/readCounts$V3*100)
colnames(mergeStats)[ncol(mergeStats)]<-"PercentMTReads"

## e. ALIGNMENT QC
aIndex<-match(processSum$sampleID, gsub("\\.bowtie", "", alignQC$Sample))
alignQC$aligned_total<-rowSums(alignQC[,c("paired_aligned_one", "paired_aligned_multi")])
mergeStats<-cbind(mergeStats,alignQC[aIndex,c("overall_alignment_rate", "aligned_total")])
## f. ENCODE METRICS
## load flagstat metrics calculated as part of encode qc pipeline
flagstat<-flagstat[match(processSum$sampleID, flagstat$V1),]
files<-list.files(paste0(alignedDir, "/ENCODEMetrics"), pattern = ".pbc.qc")
eMetrics<-NULL
for(each in files){
  
  tmp<-read.table(paste0(alignedDir, "/ENCODEMetrics/", each))
  if(ncol(tmp) == 7){
    eMetrics<-rbind(eMetrics, tmp)
  } else {
    eMetrics<-rbind(eMetrics, rep(NA, 7))
  }
}
colnames(eMetrics)<-c("TotalReadPairs","DistinctReadPairs","OneReadPair","TwoReadPairs","NRF","PBC1","PBC2")
eIndex<-match(processSum$sampleID, gsub(".pbc.qc", "", files))
eMetrics<-eMetrics[eIndex,]
mergeStats<-cbind(mergeStats,eMetrics)

## 6. FRIP
fripStats<-read.csv(paste0(peakDir, "/QCOutput/", fripFiles[1]))
for(each in fripFiles[-1]){
  fripStats<-rbind(fripStats, read.csv(paste0(peakDir, "/QCOutput/", each)))
}
fripStats<-fripStats[match(processSum$sampleID, fripStats$SampleName),]

fripStats$FripMACS2TagAlign <- fripStats$ReadsinMACS2TagAlignPeaks/fripStats$BAMTotalReads
fripStats$FripMACS2PE <- fripStats$ReadsinMACS2PEPeaks/fripStats$BAMTotalReads

#ccFiles<-list.files(alignedDir, pattern = '.subsample.cc.qc')
#crossCor<-read.csv(paste(alignedDir, ccFiles[1], sep='/'))
#for(each in ccFiles[-1]){
#  crossCor<-rbind(crossCor, read.csv(paste0(alignedDir, each,  sep='/')))
#}
#crossCor<-crossCor[match(processSum$sampleID, crossCor$SampleName),]

## load ATACQC metrics 
propNucleosomesAll<-NULL
filePaths <- list.files(file.path(alignedDir,"/QCOutput/"), pattern = "FragmentDistribution_Batch")
for(each in filePaths){
  load(paste0(alignedDir,"/QCOutput/", each))
  propNucleosomesAll<-rbind(propNucleosomesAll, propNucleosomes)
}
propNucleosomesAll<-propNucleosomesAll[match(processSum$sampleID, rownames(propNucleosomesAll)),]

## count number of samples with X million reads
readThres<-seq(0,max(mergeStats[,1], na.rm = TRUE)+10^6, 10^6)
nSamples<-matrix(data = NA, nrow = length(readThres), ncol = length(unique(pheno$sequencingBatch))+1)
for(i in readThres){
  nSamples[1+(i/10^6),1] <- sum(mergeStats[,1] > i, na.rm = TRUE)
  colNum<-2
  for(each in unique(pheno$sequencingBatch)){
    nSamples[1+(i/10^6),colNum] <- sum(mergeStats[which(pheno$sequencingBatch == each),1] > i, na.rm = TRUE)
    colNum<-colNum+1
  }
}
```

## Overview

To provide an overall summary here is a table of the number of raw reads, aligned reads (post filtering) and peaks called for each sample.

``` {r overview, fig.align = 'center', echo =FALSE}
data.frame(pheno$sampleID, mergeStats[,c(1,9)],fripStats$ReadsinMACS2TagAlignPeaks) %>%
  setNames(c('Samples', 'Raw reads', 'Aligned reads', 'Reads in peaks')) %>%
  melt(id='Samples') %>%
  ggplot(., aes(fill= variable, x=Samples, y=value))+
    geom_bar(position = 'dodge', stat = 'identity')+
    theme_bw()+
    labs(y = 'Number of reads')+
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          legend.position = 'bottom', 
          legend.title = element_blank())+
    scale_fill_manual(values = colorBlindGrey8)

```

## 1. Sequencing

### 1.1 Data summary

In total there were `r sum(c(mergeStats[,1], mergeStats[,4]))/1000000` million reads generated across these samples, with a mean of 
`r signif(mean(c(mergeStats[,1], mergeStats[,4]))/1000000,3)` million per sample (SD = `r signif(sd(c(mergeStats[,1], mergeStats[,4]))/1000000,3)` million).

```{r pressure, fig.align = 'center'}
xlab <- c('Number of Reads', '% unique reads' ,'' , 'Number of Reads', '% unique reads')
read<-c('R1','R1','','R2', 'R2')
p=NULL
for (x in 1:5){
  p[[x]]<-mergeStats %>% dplyr::select(all_of(x))%>%
          ggplot(aes(x = .[,1]))+ # select x values based on column index rather than name
          geom_histogram(bins=100, fill ='white', colour = 'black')+
          labs(title = read[x], x = xlab[x], y = 'Number of Samples')+
          theme_bw()
}
p<-p[- 3] # remove the empty list item
grid.arrange(grobs = p,ncol=2)
```

For mammalian studies, authors of the ATAC-seq protocol use a minimum of 50 million non-duplicated, non-mitochondrial mapped reads for open chromatin detection. The ENCODE pipeline recommends a minimum of 25 million for single end and 50 million for paired. In the plot below, median of the data is indicated by the orange line and 50 million and 25 million thresholds by the black lines.

``` {r minReads, fig.align = 'center'}
# plot minimum number of reads
coeff=nSamples[1,1]/100
data.frame(readThres/10^6, nSamples[,-1]) %>% 
  melt(., id='readThres.10.6') %>%
  ggplot(., aes_string(x = names(.)[1], y = names(.)[3], colour = names(.)[2]))+
  geom_line() +
  labs(x = 'Minimum number of reads (millions)', y = 'Number of Samples')+
  theme_bw()+
  geom_vline(xintercept=c((25)/0.8, 50, median(mergeStats[,1], na.rm = TRUE)/10^6), 
             colour = c('black', 'black', colorBlindGrey8[2]),
             alpha=0.9, linetype="dashed", show.legend =FALSE)+
  scale_y_continuous(sec.axis = sec_axis(trans = ~./coeff, name = '% of samples'))+
  theme(legend.position = "none")+
  scale_color_manual(values = rep('black', ncol(nSamples)))
```

### 1.2 Estimate Library Complexity

A good ATAC-seq experiment will capture enrichment at a broad range of genomic locations. The number of distinct or unique reads is an indicator of the diversity or complexity of the data. If the sample does not contain sufficient DNA and/or has been over-sequenced, you will simply be repeatedly sequencing PCR duplicates of a restricted pool of distinct DNA fragments. This is known a low-complexity library and is not desirable.  

Complexity can be assessed at two points, from both the raw sequencing reads and the aligned reads. In this section we will assess the number of unique reads as the total number of reads increases. This is equivalent to subsampling the data. The dynamics of the resulting curve indicate the complexity of the library prep and are best interpreted across a number of samples. 

``` {r uniqueReads, fig.align = 'center'}
## plot %unique reads against read number
ggplot(mergeStats[,c(1,2)], aes(x = Total.Sequences, y = total_deduplicated_percentage, colour = pheno$fraction))+
  geom_point() +
  labs(x = 'Number of Reads', y = '% unique reads')+
  theme_bw() +
  scale_color_manual(values = colorBlindGrey8[1:length(unique(pheno$fraction))])+
  theme(legend.title = element_blank(),
        legend.position = 'bottom')

## plot no reads and %unique by sequencing batch
p<-NULL
x=1
cols<-c("sequencingBatch", "fraction", "cohort", "Sequencing batch", "Cell fraction", "Brain bank")
lab <- c('Number of reads', '% unique reads', "Alignment rate", "Number of aligned reads")
for (j in 1:2){
  for (i in 1:3){
    p[[x]]<-data.frame(mergeStats[,j], pheno[,cols[i]]) %>%
      ggplot(aes(y = .[,1], x=as.factor(.[,2])))+
      geom_violin(fill = "grey80")+
      geom_boxplot(width=0.05, fill='black')+
      labs(x = cols[i+3], y = lab[j])+
      stat_summary(fun="median", 
                 geom="point", color="white")+
      theme_bw() +
      theme(axis.text.y = element_text(angle = 90), 
            axis.text = element_text(size = 7),
            axis.title = element_text(size=10))
    x<-x+1
  }
}
grid.arrange(grobs = p,ncol=3)

```

## 2. Alignment


### 2.1 Summary of alignment (pre-filtering)

The plot below shows the alignment rate and number of mapped reads per sample. While general convention is a unique mapping rate over 80% is typical for a successful ATAC-seq experiment, ENCODE would require that the percentage of mapped reads should be greater than 95%, though values >80% may be acceptable. In the plot below the pink line indicates the 80% threshold, the black indicates the 95%.  

```{r alignment rate, fig.align = 'center'}
## plot alignment rate against number of reads
ggplot(mergeStats[,c('aligned_total','overall_alignment_rate')], aes(x = aligned_total, y = overall_alignment_rate, colour = pheno$fraction))+
  geom_point() +
  geom_hline(yintercept=c(95, 80), #acceptable
             colour = c('black', colorBlindGrey8[2]),
             alpha=0.9, linetype="dashed", show.legend =FALSE)+
  labs(x = 'Number of Reads', y = 'Alignment rate')+
  theme_bw() +
  scale_color_manual(values = colorBlindGrey8[1:length(unique(pheno$fraction))])+
  theme(legend.title = element_blank(),
        legend.position = 'bottom')
```


``` {r blank, fig.align = 'center'}
## plot alignment rate amd no aligned reads by sequencing batch, cell fraction and brain bank
p<-NULL
x=1
for (j in 8:9){
  for (i in 1:3){
    p[[x]]<-data.frame(mergeStats[,j], pheno[,cols[i]]) %>%
      ggplot(aes(y = .[,1], x=as.factor(.[,2])))+
      geom_violin(fill = "grey80")+
      geom_boxplot(width=0.05, fill='black')+
      labs(x = cols[i+3], y = lab[j-5])+
      stat_summary(fun="median", 
                 geom="point", color="white")+
      theme_bw()+
      theme(axis.text.y = element_text(angle = 90), 
            axis.text = element_text(size = 7),
            axis.title = element_text(size=10))
    
    if (j==8){
      p[[x]]<-p[[x]]+geom_hline(yintercept = 80, alpha=0.7, linetype="dashed", show.legend =FALSE)
    }
    x<-x+1
  }
}
grid.arrange(grobs = p,ncol=3)

```


### 2.2 Mitochondrial genome

It can be a useful QC to assess the number of mitochondrial reads; some ATAC-Seq samples have been reported to be 80% mitochondrial reads. 

``` {r mitochondria, fig.align = 'center'}
# plot percentage of mitochondrial reads
data.frame(mergeStats$PercentMTReads, pheno$cohort) %>%
  ggplot(aes(y = .[,1], x=as.factor(.[,2])))+
      geom_violin(fill = "grey80")+
      geom_boxplot(width=0.05, fill='black')+
      labs(x = "Sequencing batch", y = "Percentage of MT reads")+
      stat_summary(fun="median", 
                 geom="point", color="white")+
      theme_bw()

```

### 2.3 Library Complexity

In this section we will assess the number of unique aligned reads as the number of total reads increases. This is equivalent to subsampling the data. The dynamics of the resulting curve indicate the complexity of the library prep and are best interpreted across a number of samples. NB this will differ slightly to the complexity curves produced earlier as this is based on just the aligned reads.

``` {r dedupreads, fig.align = 'center'}
# plot unique reads against total reads
data.frame(mergeStats[,1], mergeStats$DistinctReadPairs, pheno$fraction) %>%
  ggplot(aes(x=.[,1], y = .[,2], colour = .[,3]))+
      geom_point()+
      theme_bw()+
      labs(x = "Number of reads", y = "Number of distinct aligned reads")+
      scale_color_manual(values = colorBlindGrey8[1:length(unique(pheno$fraction))])+
      theme(legend.title = element_blank(), 
            legend.position = 'bottom')
```

We will also calculate additional statistics recommended by the ENCODE ATAC-seq pipeline: PCR Bottlenecking Coefficients 1 & 2 (PBC1 & PBC2) and Non-Redundant Fraction (NRF) and compare these to their reference values.

``` {r encode, fig.align = 'center'}
p=NULL
refs<-matrix(c(0.7, 0.9,
               0.7, 0.9, 
               1, 3), nrow = 2)
labs<-matrix(data=NA, ncol = 3, nrow = 3)
labs[2, ]<-colMeans(refs)
labsText<-list(c("Concerning", "Acceptable", "Ideal"), c("Severe", "Concerning", "None"), c("Severe", "Concerning", "None"))
for (x in 1:3){
  colNum<-x+4
  # generate the placement of the labels relative to the data
  if (min(eMetrics[,colNum]) < refs[1, x]){
    labs[1, x]<-mean(c(min(eMetrics[,colNum]), refs[1, x]))
  } else { labs[1, x]<-refs[1, x]-sd(eMetrics[,colNum]) } 
  if(max(eMetrics[,colNum]) > refs[2, x]){
    labs[3, x]<-mean(c(max(eMetrics[,colNum]), refs[2, x]))
  } else { labs[3, x]<- refs[2, x]+sd(eMetrics[,colNum]) }
  
  # create plot
  p[[x]]<-dplyr::select(eMetrics, all_of(colNum)) %>%
    ggplot(aes_string(x=names(.)[1]))+
    geom_histogram(bins = 20, fill ='white', colour = 'black')+
    labs(y = "Number of samples")+
    geom_vline(xintercept = refs[,x],alpha=0.9, linetype="dashed", show.legend =FALSE)+
    annotate("text", x = labs[,x], y = Inf, vjust = 2, label = labsText[[x]])+
    theme_bw()+
    theme(axis.text.y = element_text(angle = 90))
  
}
p<-compact(p)
grid.arrange(grobs = p, nrow = 3)

```

Correlation matrix of the QC metrics.

``` {r correlation, fig.align = 'center'}
## create correlation plot 
corMergeStats<-cbind(rowMeans(mergeStats[,c(1,4)]),rowMeans(mergeStats[,c(2,5)]), rowMeans(mergeStats[,c(3,6)]),
                     mergeStats$PercentMTReads, mergeStats$overall_alignment_rate,
                     mergeStats$DistinctReadPairs, mergeStats[,c((ncol(mergeStats)-2):ncol(mergeStats))]) 
colnames(corMergeStats)<- c('total\nreads', 'dedup', 'poor\nqual', 'mt\nreads', 'alignt\nrate', 'distinct\nreads', 
                            colnames(mergeStats[,c((ncol(mergeStats)-2):ncol(mergeStats))]))
corMergeStats<- corMergeStats[, colSums(corMergeStats, na.rm = TRUE) != 0]
corrplot.mixed(cor(corMergeStats, use = "p"), order = 'AOE', tl.cex=0.9, tl.col = 'black', upper.col = COL2('PiYG'), lower.col = COL2('PiYG'))
```

### 2.4 Fragment Size Distribution

ATAC-seq data should be enriched for specific sized fragments, so the distribution of fragment size should show periodicity. Typically there should be a large proportion of reads with fragment length < 100bp indicating nucleosome-free fragments, the plot should then show periodicity of ~ 200bp representing  enrichment of mono-, di-, and tri-nucleosome bound fragments (~200, 400, 600?p, respectively).  In the plot below, a successful ATAC-seq experiment should have a peak at ~50-100bp with a large proportion of reads less than 100 bp, and peaks at 200bp, 400bp, 600bp. If there was no chromatin in the sample the graph would have no periodicity and resemble a poisson distribution with lambda = 1).

``` {r periodicity, fig.align = 'center'}
## plot nucleosome periodicity
melt(na.omit(propNucleosomesAll)) %>%
  ggplot(aes(x=as.factor(Var2), y=value))+
      geom_violin(fill = "grey80", scale = 'width')+
      geom_boxplot(width=0.05, fill='black')+
      labs(y = "Proportion of reads", x = "Nucleosome")+
      geom_hline(yintercept = 0.5, alpha=0.9, linetype="dashed")+
      stat_summary(fun="median", geom="point", color="white")+
      scale_x_discrete(labels = c("NFR", "Mono", "Di", "Tri", "Quad"))+
      theme_bw()

# plot proportion of nucleosome free against mono
data.frame(propNucleosomesAll)%>%
  ggplot(aes(x=propNucleosomesAll[,2], y=propNucleosomesAll[,1]))+
    geom_point()+
    theme_bw()+
    labs(x= "Proportion fragments classed as mono", y = "Proportion fragments class as nucleosome free")+
    geom_abline(intercept = 0, slope = 1, alpha=0.9, linetype="dashed")+
    ylim(c(0,1))+
    xlim(c(0,max(propNucleosomesAll[,2])))+
    geom_hline(yintercept = 0.9, alpha=0.9, linetype="dashed")


```


## 3. Peak calling

### 3.1 Number of peaks

ENCODE recommends that number of peaks in each sample be greater than 150000, though values greater than 100000 are acceptable.

```{r numpeaks, results=FALSE}
data.frame(fripStats$MACS2TagAlignPeaks, fripStats$MACS2PEPeaks)%>%
  melt() %>%
  ggplot(aes(y = value, x=variable))+
      geom_violin(fill = "grey80")+
      geom_boxplot(width=0.05, fill='black')+
      labs(x = "Sequencing batch", y = "Number of peaks")+
      stat_summary(fun="median", 
                 geom="point", color="white")+
      geom_hline(yintercept = c(150000, 100000), colour = c('black', colorBlindGrey8[2]),
               alpha=0.9, linetype="dashed", show.legend =FALSE)+
      scale_x_discrete(labels = c("MACS2: Shifted tagalign", "MACS2: PE"))+
      theme_bw()

```

### 3.2 Specificity of reads in peaks

Plot of the fraction of reads in peaks called for that sample. These plots give a good indication of how "enriched" the sample is and can be considered a "signal-to-noise" measure of what proportion of the library consists of fragments from binding sites vs. background reads. According to the ENCODE standard processing pipeline for ATAC-seq the FRiP score should be > 0.3, though values greater than 0.2 are acceptable. 


```{r readsinpeaks}
# plot 
data.frame(fripStats$FripMACS2TagAlign, fripStats$FripMACS2PE)%>%
  melt() %>%
  ggplot(aes(y = value, x=variable))+
      geom_violin(fill = "grey80")+
      geom_boxplot(width=0.05, fill='black')+
      labs(x = "Sequencing batch", y = "Fraction reads in peaks")+
      stat_summary(fun="median", 
                 geom="point", color="white")+
      geom_hline(yintercept = c(0.3, 0.2), colour = c('black', colorBlindGrey8[2]),
               alpha=0.9, linetype="dashed", show.legend =FALSE)+
      scale_x_discrete(labels = c("MACS2: Shifted tagalign", "MACS2: PE"))+
      theme_bw()

# plot frip against number of peaks
p=NULL
title<-c('MACS2: Shifted Tagalign', 'MACS2: PE')
for (x in c(2, 3)){
  y<-x+6
  z<-x*2
  p[[x]]<-ggplot(fripStats, aes(x=fripStats[,z], y = fripStats[,y], colour = pheno$fraction))+
    geom_point()+
    theme_bw()+
    labs(title = title[x-1], x = "Number of peaks", y = "Fraction reads in peaks")+
    scale_color_manual(values = colorBlindGrey8[1:length(unique(pheno$fraction))])+
    theme(legend.title = element_blank(), 
          legend.position = 'bottom')
  p[[4]]<-get_legend(p[[x]]) #get the legend to add as a common legend
  p[[x]]<-p[[x]]+theme(legend.position = 'none')
}
p<-compact(p) # remove the null item

grid.arrange(grobs = p, ncol=2, nrow = 2, 
             layout_matrix = rbind(c(1,2), c(3,3)),
             widths = c(2.7, 2.7), heights = c(2.5, 0.2))
```